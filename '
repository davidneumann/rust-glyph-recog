use std::{cmp, collections::HashMap, fs::{self, File}, io::Read};
use super::{glyph::Glyph, glyph_rays::GlyphRays};

pub struct GlyphDataset {
    glyph_dict: HashMap<u8, HashMap<u16, Vec<Glyph>>>,
    min_height: u8,
    min_width: u16,
}

impl GlyphDataset {
    pub fn build_from_dir(input: &str) -> GlyphDataset {
        //let mut glyph_dict : HashMap<(u16, u8), HashMap<String, GlyphRays>> = HashMap::new();
        let mut glyph_dict : HashMap<u8, HashMap<u16, Vec<Glyph>>> = HashMap::new();
        let mut min_height = std::u8::MAX;
        let mut min_width = std::u16::MAX;
        for x in fs::read_dir(input).unwrap().into_iter().filter(|x| x.as_ref().unwrap().path().is_dir())
        {
            let dir_name = x.unwrap().file_name().to_str().unwrap().to_owned();
            let c = std::char::from_u32(dir_name.parse::<u32>().unwrap()).unwrap().to_string();
            let files = fs::read_dir(input.to_owned() + &dir_name).unwrap()
                .into_iter()
                .filter(|x| x.as_ref().unwrap().path().file_name().unwrap() != "0.dat")
                .map(|x| x.unwrap());
            for file in files {
                let file_name = file.path().file_name().unwrap().to_str().unwrap().to_owned();
                let (width, height) = get_size_from_dat(&(input.to_owned() + &dir_name + "/" + &file_name));
                let height_dict = glyph_dict.entry(height).or_insert(HashMap::new());
                let width_vec = height_dict.entry(width).or_insert(vec!());
                if !width_vec.iter().any(|g| g.value == c) {
                    println!("Using {} for {} at {},{}", file_name, dir_name, height, width);
                    let ray = GlyphRays::from_file(&(input.to_owned() + &dir_name + "/" + &file_name));
                    min_height = cmp::min(min_height, ray.height);
                    min_width = cmp::min(min_width, ray.width);
                    width_vec.push(Glyph{
                        value: c.clone(),
                        ray,
                    });
                }
            }
        }

        GlyphDataset{
            glyph_dict,
            min_height,
            min_width,
        }
    }

    pub fn get(&self, width:&u16, height:&u8) -> Option<&Vec<Glyph>> {
        let _debug = self.glyph_dict.get(height);
        match self.glyph_dict.get(height) {
            Some(d) => d.get(width),
            None => None
        }
    }

    pub fn fuzzy_get(&self, max_width:u16, max_height:u8, overlap:&GlyphRays) -> Vec<&Glyph> {
        let mut results = Vec::new();
        for height in self.min_height..max_height {
            match self.glyph_dict.get(&height) {
                Some(d) =>
                {
                    for width in self.min_width..max_width {
                        let mut min_t2b = std::u8::MAX;
                        for i in 0..width as usize{
                            min_t2b = cmp::min(min_t2b, overlap.t2b[i]);
                        }
                        let valid_top = overlap.pixels_from_top + (min_t2b as i8);
                        let valid_height = overlap.height - (valid_top as u8) - 1;
                        match d.get(&width) {
                            Some(vec) => {
                                for candidate in vec {
                                    if (candidate.ray.pixels_from_top - valid_top).abs() < 2 && candidate.ray.height > valid_height {
                                        results.push(candidate);
                                    }
                                }
                                results.extend(vec);
                            }
                            _ => ()
                        }
                    }
                }
                _ => ()
            }
        }
        results
    }
}

fn _get_valid_info(overlap: &GlyphRays, width:u16) {
    let mut min_top = std::u8::MAX;
    for i in 0..width as usize {
        min_top = cmp::min(min_top, overlap.t2b[i]);
    }
    let pixels_from_top = overlap.pixels_from_top + (min_top as i8) - 1;
}

fn get_size_from_dat(input: &str) -> (u16, u8) {
    let mut fin = File::open(input).unwrap();

    let mut buffer = [0; 2];
    fin.read(&mut buffer).unwrap();
    let width = u16::from_le_bytes(buffer);
    let mut buffer = [0; 1];
    fin.read(&mut buffer).unwrap();
    let height = u8::from_le_bytes(buffer);
    (width, height)
}
